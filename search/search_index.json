{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b","title":"Home"},{"location":"#_1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b"},{"location":"lab1/lab1/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0426\u0435\u043b\u044c \u0440\u0430\u0431\u043e\u0442\u044b \u041d\u0430\u0443\u0447\u0438\u0442\u044c\u0441\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u044b\u0432\u0430\u0442\u044c \u043f\u043e\u043b\u043d\u043e\u0446\u0435\u043d\u043d\u043e\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0444\u0440\u0435\u0439\u043c\u0432\u043e\u0440\u043a\u0430 FastAPI, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0443 \u0441 \u0431\u0430\u0437\u043e\u0439 \u0434\u0430\u043d\u043d\u044b\u0445, \u0430\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0438 \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u0435 \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0441\u0432\u044f\u0437\u0435\u0439 \u043c\u0435\u0436\u0434\u0443 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u044f\u043c\u0438. \u0422\u0435\u043c\u0430 \u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0442\u0430\u0439\u043c \u043c\u0435\u043d\u0435\u0434\u0436\u043c\u0435\u043d\u0442\u0430 \u0421\u0442\u0435\u043a \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0439 FastAPI (\u0444\u0440\u0435\u0439\u043c\u0432\u043e\u0440\u043a) PosgreSQL (\u0411\u0414) Alembic (\u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0438) uvicorn (\u0437\u0430\u043f\u0443\u0441\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0430) \u0425\u043e\u0434 \u0440\u0430\u0431\u043e\u0442\u044b \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043d\u0443\u0436\u043d\u044b\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u043c \u043c\u043e\u0434\u0435\u043b\u0438: from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship from datetime import datetime class User(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) username: str = Field(index=True, unique=True) email: str = Field(index=True, unique=True) hashed_password: str tasks: List[\"Task\"] = Relationship(back_populates=\"user\") schedules: List[\"Schedule\"] = Relationship(back_populates=\"user\") class Task(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) title: str description: Optional[str] = None deadline: Optional[datetime] = None priority: int = Field(default=1) user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") user: Optional[User] = Relationship(back_populates=\"tasks\") categories: List[\"Category\"] = Relationship(back_populates=\"tasks\", link_model=\"TaskCategory\") time_logs: List[\"TimeLog\"] = Relationship(back_populates=\"task\") class Category(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(unique=True) tasks: List[Task] = Relationship(back_populates=\"categories\", link_model=\"TaskCategory\") class TaskCategory(SQLModel, table=True): task_id: Optional[int] = Field(default=None, foreign_key=\"task.id\", primary_key=True) category_id: Optional[int] = Field(default=None, foreign_key=\"category.id\", primary_key=True) association_priority: int = Field(default=1) class TimeLog(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) task_id: Optional[int] = Field(default=None, foreign_key=\"task.id\") start_time: datetime end_time: Optional[datetime] = None duration: Optional[int] = None task: Optional[Task] = Relationship(back_populates=\"time_logs\") class Schedule(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") date: datetime description: Optional[str] = None user: Optional[User] = Relationship(back_populates=\"schedules\") Users (\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438) Tasks (\u0437\u0430\u0434\u0430\u0447\u0438, one-to-many \u0441 Users \u0438 many-to-many \u0441 Categories) Categories (\u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438) TaskCategories (\u0430\u0441\u0441\u043e\u0446\u0438\u0430\u0442\u0438\u0432\u043d\u0430\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u0430 \u0441 extra \u043f\u043e\u043b\u0435\u043c association_priority) TimeLogs (\u043b\u043e\u0433\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, one-to-many \u0441 Tasks) Schedules (\u0440\u0430\u0441\u043f\u0438\u0441\u0430\u043d\u0438\u044f, one-to-many \u0441 Users) \u0412 schemas.py \u0441\u043e\u0437\u0434\u0430\u0435\u043c Pydantic-\u0441\u0445\u0435\u043c\u044b \u0434\u043b\u044f \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u0438 \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0441 \u0411\u0414 \u0438 \u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0439 from sqlmodel import SQLModel, create_engine, Session from sqlalchemy.ext.asyncio import AsyncEngine import os from dotenv import load_dotenv load_dotenv() DATABASE_URL = os.getenv(\"DATABASE_URL\") engine = create_engine(DATABASE_URL, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c Alembic \u0438 \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0438 \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u043c CRUD \u0438 \u0440\u043e\u0443\u0442\u0435\u0440\u044b \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u043c \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044e from passlib.context import CryptContext from datetime import datetime, timedelta from jose import JWTError, jwt import os from dotenv import load_dotenv load_dotenv() pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") SECRET_KEY = os.getenv(\"SECRET_KEY\") ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c uvicorn main:app --reload \u0422\u0435\u0441\u0442\u0438\u0440\u0443\u0435\u043c \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e Swagger \u0412\u044b\u0432\u043e\u0434 \u0412 \u0440\u0430\u043c\u043a\u0430\u0445 \u0434\u0430\u043d\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0430 FastAPI \u0434\u043b\u044f \u0442\u0430\u0439\u043c-\u043c\u0435\u043d\u0435\u0434\u0436\u043c\u0435\u043d\u0442\u0430. \u0421\u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0430 \u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u0430 \u0440\u0435\u043b\u044f\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u0411\u0414 PostgreSQL. \u0412\u043d\u0435\u0434\u0440\u0435\u043d\u0430 \u0430\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u043f\u043e JWT-\u0442\u043e\u043a\u0435\u043d\u0430\u043c.","title":"FastAPI app"},{"location":"lab1/lab1/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"lab1/lab1/#_1","text":"\u041d\u0430\u0443\u0447\u0438\u0442\u044c\u0441\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u044b\u0432\u0430\u0442\u044c \u043f\u043e\u043b\u043d\u043e\u0446\u0435\u043d\u043d\u043e\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0444\u0440\u0435\u0439\u043c\u0432\u043e\u0440\u043a\u0430 FastAPI, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0443 \u0441 \u0431\u0430\u0437\u043e\u0439 \u0434\u0430\u043d\u043d\u044b\u0445, \u0430\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0438 \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u0435 \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0441\u0432\u044f\u0437\u0435\u0439 \u043c\u0435\u0436\u0434\u0443 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u044f\u043c\u0438.","title":"\u0426\u0435\u043b\u044c \u0440\u0430\u0431\u043e\u0442\u044b"},{"location":"lab1/lab1/#_2","text":"\u041f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0442\u0430\u0439\u043c \u043c\u0435\u043d\u0435\u0434\u0436\u043c\u0435\u043d\u0442\u0430","title":"\u0422\u0435\u043c\u0430"},{"location":"lab1/lab1/#_3","text":"FastAPI (\u0444\u0440\u0435\u0439\u043c\u0432\u043e\u0440\u043a) PosgreSQL (\u0411\u0414) Alembic (\u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0438) uvicorn (\u0437\u0430\u043f\u0443\u0441\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0430)","title":"\u0421\u0442\u0435\u043a \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0439"},{"location":"lab1/lab1/#_4","text":"\u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043d\u0443\u0436\u043d\u044b\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u043c \u043c\u043e\u0434\u0435\u043b\u0438: from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship from datetime import datetime class User(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) username: str = Field(index=True, unique=True) email: str = Field(index=True, unique=True) hashed_password: str tasks: List[\"Task\"] = Relationship(back_populates=\"user\") schedules: List[\"Schedule\"] = Relationship(back_populates=\"user\") class Task(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) title: str description: Optional[str] = None deadline: Optional[datetime] = None priority: int = Field(default=1) user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") user: Optional[User] = Relationship(back_populates=\"tasks\") categories: List[\"Category\"] = Relationship(back_populates=\"tasks\", link_model=\"TaskCategory\") time_logs: List[\"TimeLog\"] = Relationship(back_populates=\"task\") class Category(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(unique=True) tasks: List[Task] = Relationship(back_populates=\"categories\", link_model=\"TaskCategory\") class TaskCategory(SQLModel, table=True): task_id: Optional[int] = Field(default=None, foreign_key=\"task.id\", primary_key=True) category_id: Optional[int] = Field(default=None, foreign_key=\"category.id\", primary_key=True) association_priority: int = Field(default=1) class TimeLog(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) task_id: Optional[int] = Field(default=None, foreign_key=\"task.id\") start_time: datetime end_time: Optional[datetime] = None duration: Optional[int] = None task: Optional[Task] = Relationship(back_populates=\"time_logs\") class Schedule(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") date: datetime description: Optional[str] = None user: Optional[User] = Relationship(back_populates=\"schedules\") Users (\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438) Tasks (\u0437\u0430\u0434\u0430\u0447\u0438, one-to-many \u0441 Users \u0438 many-to-many \u0441 Categories) Categories (\u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438) TaskCategories (\u0430\u0441\u0441\u043e\u0446\u0438\u0430\u0442\u0438\u0432\u043d\u0430\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u0430 \u0441 extra \u043f\u043e\u043b\u0435\u043c association_priority) TimeLogs (\u043b\u043e\u0433\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, one-to-many \u0441 Tasks) Schedules (\u0440\u0430\u0441\u043f\u0438\u0441\u0430\u043d\u0438\u044f, one-to-many \u0441 Users) \u0412 schemas.py \u0441\u043e\u0437\u0434\u0430\u0435\u043c Pydantic-\u0441\u0445\u0435\u043c\u044b \u0434\u043b\u044f \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u0438 \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0441 \u0411\u0414 \u0438 \u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0439 from sqlmodel import SQLModel, create_engine, Session from sqlalchemy.ext.asyncio import AsyncEngine import os from dotenv import load_dotenv load_dotenv() DATABASE_URL = os.getenv(\"DATABASE_URL\") engine = create_engine(DATABASE_URL, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c Alembic \u0438 \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0438 \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u043c CRUD \u0438 \u0440\u043e\u0443\u0442\u0435\u0440\u044b \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u043c \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044e from passlib.context import CryptContext from datetime import datetime, timedelta from jose import JWTError, jwt import os from dotenv import load_dotenv load_dotenv() pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") SECRET_KEY = os.getenv(\"SECRET_KEY\") ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c uvicorn main:app --reload \u0422\u0435\u0441\u0442\u0438\u0440\u0443\u0435\u043c \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e Swagger","title":"\u0425\u043e\u0434 \u0440\u0430\u0431\u043e\u0442\u044b"},{"location":"lab1/lab1/#_5","text":"\u0412 \u0440\u0430\u043c\u043a\u0430\u0445 \u0434\u0430\u043d\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0430 FastAPI \u0434\u043b\u044f \u0442\u0430\u0439\u043c-\u043c\u0435\u043d\u0435\u0434\u0436\u043c\u0435\u043d\u0442\u0430. \u0421\u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0430 \u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u0430 \u0440\u0435\u043b\u044f\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u0411\u0414 PostgreSQL. \u0412\u043d\u0435\u0434\u0440\u0435\u043d\u0430 \u0430\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u043f\u043e JWT-\u0442\u043e\u043a\u0435\u043d\u0430\u043c.","title":"\u0412\u044b\u0432\u043e\u0434"},{"location":"lab2/lab2/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21162 \u0426\u0435\u043b\u044c \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0442\u0440\u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 Python \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 threading, multiprocessing \u0438 async. \u0412\u0441\u0435 \u0441\u043e\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u044b \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445. \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21161 Threading import time import threading def calculate_partial_sum(start, end): return end * (end + 1) // 2 - (start - 1) * start // 2 N = 10000000000000 NUM_THREADS = 4 chunk_size = N // NUM_THREADS start_time = time.time() threads = [] results = [0] * NUM_THREADS for i in range(NUM_THREADS): start = i * chunk_size + 1 end = (i + 1) * chunk_size if i < NUM_THREADS - 1 else N def target(idx, s, e): results[idx] = calculate_partial_sum(s, e) thread = threading.Thread(target=target, args=(i, start, end)) threads.append(thread) thread.start() for thread in threads: thread.join() total_sum = sum(results) end_time = time.time() print(f\"Threading sum: {total_sum}\") print(f\"Threading time: {end_time - start_time} seconds\") \u0412\u044b\u0432\u043e\u0434: Multiprocessing import time from multiprocessing import Process, Manager def calculate_partial_sum(start, end): return end * (end + 1) // 2 - (start - 1) * start // 2 def target(idx, s, e, results): results[idx] = calculate_partial_sum(s, e) if __name__ == '__main__': N = 10000000000000 NUM_PROCESSES = 4 chunk_size = N // NUM_PROCESSES start_time = time.time() manager = Manager() results = manager.list([0] * NUM_PROCESSES) processes = [] for i in range(NUM_PROCESSES): start = i * chunk_size + 1 end = (i + 1) * chunk_size if i < NUM_PROCESSES - 1 else N process = Process(target=target, args=(i, start, end, results)) processes.append(process) process.start() for process in processes: process.join() total_sum = sum(results) end_time = time.time() print(f\"Multiprocessing sum: {total_sum}\") print(f\"Multiprocessing time: {end_time - start_time} seconds\") \u0412\u044b\u0432\u043e\u0434: Async import time import asyncio def calculate_partial_sum(start, end): return end * (end + 1) // 2 - (start - 1) * start // 2 async def async_calculate_partial_sum(start, end): return calculate_partial_sum(start, end) N = 10000000000000 NUM_TASKS = 4 chunk_size = N // NUM_TASKS async def main(): start_time = time.time() tasks = [] for i in range(NUM_TASKS): start = i * chunk_size + 1 end = (i + 1) * chunk_size if i < NUM_TASKS - 1 else N task = async_calculate_partial_sum(start, end) tasks.append(task) results = await asyncio.gather(*tasks) total_sum = sum(results) end_time = time.time() print(f\"Async sum: {total_sum}\") print(f\"Async time: {end_time - start_time} seconds\") asyncio.run(main()) \u0412\u044b\u0432\u043e\u0434: \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21162 Threading \u0412\u044b\u0432\u043e\u0434: Multiprocessing \u0412\u044b\u0432\u043e\u0434: Async \u0412\u044b\u0432\u043e\u0434: \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u041f\u043e\u0434\u0445\u043e\u0434 \u0412\u0440\u0435\u043c\u044f 1 \u0412\u0440\u0435\u043c\u044f 2 Threading 0.000198 \u0441\u0435\u043a 1.32 \u0441\u0435\u043a Multiprocessing 0.128238 \u0441\u0435\u043a 4.09 \u0441\u0435\u043a Async 0.000086 \u0441\u0435\u043a 1.34 \u0441\u0435\u043a \u0412\u044b\u0432\u043e\u0434\u044b \u0412 \u0445\u043e\u0434\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u0431\u044b\u043b\u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u044b \u0442\u0440\u0438 \u043f\u043e\u0434\u0445\u043e\u0434\u0430 \u043a \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u043c\u0443 \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0443: Threading - \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447, \u0442\u0440\u0435\u0431\u0443\u044e\u0449\u0438\u0445 \u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439 \u0432\u0432\u043e\u0434\u0430-\u0432\u044b\u0432\u043e\u0434\u0430, \u043d\u043e GIL \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0438\u0432\u0430\u0435\u0442 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u044c. Multiprocessing - \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u043d\u0430\u0438\u043b\u0443\u0447\u0448\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0434\u043b\u044f CPU-bound \u0437\u0430\u0434\u0430\u0447, \u0442\u0430\u043a \u043a\u0430\u043a \u043a\u0430\u0436\u0434\u044b\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e. Async - \u0445\u043e\u0440\u043e\u0448\u043e \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u0434\u043b\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0445 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439 \u0432\u0432\u043e\u0434\u0430-\u0432\u044b\u0432\u043e\u0434\u0430, \u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u044b, \u043d\u043e \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043e\u0436\u0438\u0434\u0430\u044e\u0449\u0438\u0445 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439.","title":"Parsing"},{"location":"lab2/lab2/#no2","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21162"},{"location":"lab2/lab2/#_1","text":"\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0442\u0440\u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 Python \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 threading, multiprocessing \u0438 async. \u0412\u0441\u0435 \u0441\u043e\u0431\u0440\u0430\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u044b \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445.","title":"\u0426\u0435\u043b\u044c"},{"location":"lab2/lab2/#no1","text":"Threading import time import threading def calculate_partial_sum(start, end): return end * (end + 1) // 2 - (start - 1) * start // 2 N = 10000000000000 NUM_THREADS = 4 chunk_size = N // NUM_THREADS start_time = time.time() threads = [] results = [0] * NUM_THREADS for i in range(NUM_THREADS): start = i * chunk_size + 1 end = (i + 1) * chunk_size if i < NUM_THREADS - 1 else N def target(idx, s, e): results[idx] = calculate_partial_sum(s, e) thread = threading.Thread(target=target, args=(i, start, end)) threads.append(thread) thread.start() for thread in threads: thread.join() total_sum = sum(results) end_time = time.time() print(f\"Threading sum: {total_sum}\") print(f\"Threading time: {end_time - start_time} seconds\") \u0412\u044b\u0432\u043e\u0434: Multiprocessing import time from multiprocessing import Process, Manager def calculate_partial_sum(start, end): return end * (end + 1) // 2 - (start - 1) * start // 2 def target(idx, s, e, results): results[idx] = calculate_partial_sum(s, e) if __name__ == '__main__': N = 10000000000000 NUM_PROCESSES = 4 chunk_size = N // NUM_PROCESSES start_time = time.time() manager = Manager() results = manager.list([0] * NUM_PROCESSES) processes = [] for i in range(NUM_PROCESSES): start = i * chunk_size + 1 end = (i + 1) * chunk_size if i < NUM_PROCESSES - 1 else N process = Process(target=target, args=(i, start, end, results)) processes.append(process) process.start() for process in processes: process.join() total_sum = sum(results) end_time = time.time() print(f\"Multiprocessing sum: {total_sum}\") print(f\"Multiprocessing time: {end_time - start_time} seconds\") \u0412\u044b\u0432\u043e\u0434: Async import time import asyncio def calculate_partial_sum(start, end): return end * (end + 1) // 2 - (start - 1) * start // 2 async def async_calculate_partial_sum(start, end): return calculate_partial_sum(start, end) N = 10000000000000 NUM_TASKS = 4 chunk_size = N // NUM_TASKS async def main(): start_time = time.time() tasks = [] for i in range(NUM_TASKS): start = i * chunk_size + 1 end = (i + 1) * chunk_size if i < NUM_TASKS - 1 else N task = async_calculate_partial_sum(start, end) tasks.append(task) results = await asyncio.gather(*tasks) total_sum = sum(results) end_time = time.time() print(f\"Async sum: {total_sum}\") print(f\"Async time: {end_time - start_time} seconds\") asyncio.run(main()) \u0412\u044b\u0432\u043e\u0434:","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21161"},{"location":"lab2/lab2/#no2_1","text":"Threading \u0412\u044b\u0432\u043e\u0434: Multiprocessing \u0412\u044b\u0432\u043e\u0434: Async \u0412\u044b\u0432\u043e\u0434:","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21162"},{"location":"lab2/lab2/#_2","text":"\u041f\u043e\u0434\u0445\u043e\u0434 \u0412\u0440\u0435\u043c\u044f 1 \u0412\u0440\u0435\u043c\u044f 2 Threading 0.000198 \u0441\u0435\u043a 1.32 \u0441\u0435\u043a Multiprocessing 0.128238 \u0441\u0435\u043a 4.09 \u0441\u0435\u043a Async 0.000086 \u0441\u0435\u043a 1.34 \u0441\u0435\u043a","title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b"},{"location":"lab2/lab2/#_3","text":"\u0412 \u0445\u043e\u0434\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u0431\u044b\u043b\u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u044b \u0442\u0440\u0438 \u043f\u043e\u0434\u0445\u043e\u0434\u0430 \u043a \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u043c\u0443 \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0443: Threading - \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447, \u0442\u0440\u0435\u0431\u0443\u044e\u0449\u0438\u0445 \u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439 \u0432\u0432\u043e\u0434\u0430-\u0432\u044b\u0432\u043e\u0434\u0430, \u043d\u043e GIL \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0438\u0432\u0430\u0435\u0442 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u044c. Multiprocessing - \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u043d\u0430\u0438\u043b\u0443\u0447\u0448\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0434\u043b\u044f CPU-bound \u0437\u0430\u0434\u0430\u0447, \u0442\u0430\u043a \u043a\u0430\u043a \u043a\u0430\u0436\u0434\u044b\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e. Async - \u0445\u043e\u0440\u043e\u0448\u043e \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u0434\u043b\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0445 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439 \u0432\u0432\u043e\u0434\u0430-\u0432\u044b\u0432\u043e\u0434\u0430, \u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u044b, \u043d\u043e \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043e\u0436\u0438\u0434\u0430\u044e\u0449\u0438\u0445 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439.","title":"\u0412\u044b\u0432\u043e\u0434\u044b"},{"location":"lab3/lab3/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21163. \u0426\u0435\u043b\u044c \u041d\u0430\u0443\u0447\u0438\u0442\u044c\u0441\u044f \u0443\u043f\u0430\u043a\u043e\u0432\u044b\u0432\u0430\u0442\u044c FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0432 Docker, \u0438\u043d\u0442\u0435\u0433\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0441\u0435\u0440 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u0431\u0430\u0437\u043e\u0439 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0441\u0435\u0440 \u0447\u0435\u0440\u0435\u0437 API \u0438 \u043e\u0447\u0435\u0440\u0435\u0434\u044c. \u0425\u043e\u0434 \u0440\u0430\u0431\u043e\u0442\u044b \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u043c \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 pip install celery redis requests beautifulsoup4 aiohttp \u041f\u0430\u0440\u0441\u0435\u0440 \u043a\u0430\u043a \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u0441\u0435\u0440\u0432\u0438\u0441 from fastapi import FastAPI, HTTPException import asyncio import aiohttp from bs4 import BeautifulSoup from typing import List app = FastAPI(title=\"Parser Service\") async def parse_url(url: str) -> str: try: async with aiohttp.ClientSession() as session: async with session.get(url, timeout=5) as response: text = await response.text() soup = BeautifulSoup(text, 'html.parser') title = soup.title.string.strip() if soup.title else \"No title\" return title except aiohttp.ClientError as e: raise HTTPException(status_code=500, detail=f\"Error parsing {url}: {e}\") @app.post(\"/parse\", response_model=List[dict]) async def parse_urls(urls: List[str]): tasks = [parse_url(url) for url in urls] titles = await asyncio.gather(*tasks, return_exceptions=True) results = [{\"url\": urls[i], \"title\": titles[i] if not isinstance(titles[i], Exception) else str(titles[i])} for i in range(len(urls))] return results \u0421\u043e\u0437\u0434\u0430\u0439\u0435\u043c requirements.txt \u0420\u0430\u0437\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0434\u043e\u043a\u0435\u0440\u0444\u0430\u0439\u043b\u044b \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u0421\u043e\u0437\u0434\u0430\u0435\u043c Docker Compose \u0444\u0430\u0439\u043b\u0430 services: db: image: postgres:13 environment: POSTGRES_USER: postgres POSTGRES_PASSWORD: your_password POSTGRES_DB: time_manager_db ports: - \"5432:5432\" volumes: - db_data:/var/lib/postgresql/data fastapi: build: . ports: - \"8000:8000\" environment: DATABASE_URL: postgresql://postgres:your_password@db/time_manager_db SECRET_KEY: your_random_secret_key depends_on: - db command: [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"] parser: build: ./task2 ports: - \"8001:8001\" command: [\"uvicorn\", \"parser_app:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8001\"] redis: image: redis:6 ports: - \"6379:6379\" celery_worker: build: . command: celery -A celery_app worker --loglevel=info environment: DATABASE_URL: postgresql://postgres:your_password@db/time_manager_db CELERY_BROKER_URL: redis://redis:6379/0 CELERY_RESULT_BACKEND: redis://redis:6379/0 depends_on: - db - redis - parser volumes: db_data: \u0418\u043d\u0442\u0435\u0433\u0440\u0438\u0440\u0443\u0435\u043c Celery \u0438 \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0437\u0430\u0434\u0430\u0447\u0438 from celery_app import app import requests from app.crud.tasks import create_task from app.schemas import TaskCreate from app.connection import get_session @app.task def parse_and_save_task(url: str, user_id: int): try: parser_url = \"http://parser:8001/parse\" response = requests.post(parser_url, json=[url]) response.raise_for_status() results = response.json() title = results[0]['title'] if results else \"No title\" with get_session() as session: task = TaskCreate(title=title, description=url) create_task(session, task, user_id) return {\"status\": \"success\", \"url\": url, \"title\": title} except Exception as e: return {\"status\": \"error\", \"message\": str(e)} \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u044d\u043d\u0434\u043f\u043e\u0438\u043d\u0442 \u0434\u043b\u044f \u0432\u044b\u0437\u043e\u0432\u0430 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 @router.post(\"/parse\") def parse_url(url: str, current_user: User = Depends(get_current_user)): task = parse_and_save_task.delay(url, current_user.id) return {\"task_id\": task.id, \"message\": \"Parsing started asynchronously\"} \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0435\u043c \u0412\u044b\u0432\u043e\u0434\u044b \u0412 \u0445\u043e\u0434\u0435 \u044d\u0442\u043e\u0439 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u044f \u043d\u0430\u0443\u0447\u0438\u043b\u0441\u044f \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0441 \u0434\u043e\u043a\u0435\u0440\u043e\u043c \u0438 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0442\u044c \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u0442\u043e\u0447\u043d\u044b\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.","title":"Docker"},{"location":"lab3/lab3/#no3","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21163."},{"location":"lab3/lab3/#_1","text":"\u041d\u0430\u0443\u0447\u0438\u0442\u044c\u0441\u044f \u0443\u043f\u0430\u043a\u043e\u0432\u044b\u0432\u0430\u0442\u044c FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0432 Docker, \u0438\u043d\u0442\u0435\u0433\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0441\u0435\u0440 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u0431\u0430\u0437\u043e\u0439 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0441\u0435\u0440 \u0447\u0435\u0440\u0435\u0437 API \u0438 \u043e\u0447\u0435\u0440\u0435\u0434\u044c.","title":"\u0426\u0435\u043b\u044c"},{"location":"lab3/lab3/#_2","text":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u043c \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 pip install celery redis requests beautifulsoup4 aiohttp \u041f\u0430\u0440\u0441\u0435\u0440 \u043a\u0430\u043a \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u0441\u0435\u0440\u0432\u0438\u0441 from fastapi import FastAPI, HTTPException import asyncio import aiohttp from bs4 import BeautifulSoup from typing import List app = FastAPI(title=\"Parser Service\") async def parse_url(url: str) -> str: try: async with aiohttp.ClientSession() as session: async with session.get(url, timeout=5) as response: text = await response.text() soup = BeautifulSoup(text, 'html.parser') title = soup.title.string.strip() if soup.title else \"No title\" return title except aiohttp.ClientError as e: raise HTTPException(status_code=500, detail=f\"Error parsing {url}: {e}\") @app.post(\"/parse\", response_model=List[dict]) async def parse_urls(urls: List[str]): tasks = [parse_url(url) for url in urls] titles = await asyncio.gather(*tasks, return_exceptions=True) results = [{\"url\": urls[i], \"title\": titles[i] if not isinstance(titles[i], Exception) else str(titles[i])} for i in range(len(urls))] return results \u0421\u043e\u0437\u0434\u0430\u0439\u0435\u043c requirements.txt \u0420\u0430\u0437\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0434\u043e\u043a\u0435\u0440\u0444\u0430\u0439\u043b\u044b \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0438 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u0421\u043e\u0437\u0434\u0430\u0435\u043c Docker Compose \u0444\u0430\u0439\u043b\u0430 services: db: image: postgres:13 environment: POSTGRES_USER: postgres POSTGRES_PASSWORD: your_password POSTGRES_DB: time_manager_db ports: - \"5432:5432\" volumes: - db_data:/var/lib/postgresql/data fastapi: build: . ports: - \"8000:8000\" environment: DATABASE_URL: postgresql://postgres:your_password@db/time_manager_db SECRET_KEY: your_random_secret_key depends_on: - db command: [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"] parser: build: ./task2 ports: - \"8001:8001\" command: [\"uvicorn\", \"parser_app:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8001\"] redis: image: redis:6 ports: - \"6379:6379\" celery_worker: build: . command: celery -A celery_app worker --loglevel=info environment: DATABASE_URL: postgresql://postgres:your_password@db/time_manager_db CELERY_BROKER_URL: redis://redis:6379/0 CELERY_RESULT_BACKEND: redis://redis:6379/0 depends_on: - db - redis - parser volumes: db_data: \u0418\u043d\u0442\u0435\u0433\u0440\u0438\u0440\u0443\u0435\u043c Celery \u0438 \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0437\u0430\u0434\u0430\u0447\u0438 from celery_app import app import requests from app.crud.tasks import create_task from app.schemas import TaskCreate from app.connection import get_session @app.task def parse_and_save_task(url: str, user_id: int): try: parser_url = \"http://parser:8001/parse\" response = requests.post(parser_url, json=[url]) response.raise_for_status() results = response.json() title = results[0]['title'] if results else \"No title\" with get_session() as session: task = TaskCreate(title=title, description=url) create_task(session, task, user_id) return {\"status\": \"success\", \"url\": url, \"title\": title} except Exception as e: return {\"status\": \"error\", \"message\": str(e)} \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u044d\u043d\u0434\u043f\u043e\u0438\u043d\u0442 \u0434\u043b\u044f \u0432\u044b\u0437\u043e\u0432\u0430 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 @router.post(\"/parse\") def parse_url(url: str, current_user: User = Depends(get_current_user)): task = parse_and_save_task.delay(url, current_user.id) return {\"task_id\": task.id, \"message\": \"Parsing started asynchronously\"} \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0435\u043c","title":"\u0425\u043e\u0434 \u0440\u0430\u0431\u043e\u0442\u044b"},{"location":"lab3/lab3/#_3","text":"\u0412 \u0445\u043e\u0434\u0435 \u044d\u0442\u043e\u0439 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u044f \u043d\u0430\u0443\u0447\u0438\u043b\u0441\u044f \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0441 \u0434\u043e\u043a\u0435\u0440\u043e\u043c \u0438 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0442\u044c \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u0442\u043e\u0447\u043d\u044b\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.","title":"\u0412\u044b\u0432\u043e\u0434\u044b"}]}